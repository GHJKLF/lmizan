CREATE OR REPLACE FUNCTION public.run_anomaly_detection(p_date date DEFAULT CURRENT_DATE) RETURNS jsonb LANGUAGE plpgsql SECURITY DEFINER SET search_path TO 'public' AS $$ DECLARE v_uid uuid := auth.uid(); v_checked int := 0; v_found int := 0; v_auto int := 0; rec record; BEGIN FOR rec IN WITH fx_rates(curr, rate) AS (VALUES ('EUR', 1.0), ('USD', 0.92), ('MAD', 0.092), ('GBP', 1.17), ('ILS', 0.25), ('DKK', 0.134), ('SEK', 0.088), ('HKD', 0.12), ('CAD', 0.67), ('AUD', 0.60), ('CHF', 1.05), ('PLN', 0.23), ('NZD', 0.55), ('CNY', 0.13), ('JPY', 0.0063), ('AED', 0.25)), acct_currencies AS (SELECT DISTINCT account, upper(currency) AS currency FROM transactions WHERE user_id = v_uid AND account IS NOT NULL AND currency IS NOT NULL), yesterday_bal AS (SELECT t.account, upper(t.currency) AS currency, SUM(CASE WHEN t.type = 'Inflow' THEN t.amount WHEN t.type = 'Outflow' THEN -t.amount ELSE 0 END) AS balance FROM transactions t WHERE t.user_id = v_uid AND t.date <= (p_date - 1) AND t.type IN ('Inflow', 'Outflow') GROUP BY t.account, upper(t.currency)), today_flows AS (SELECT t.account, upper(t.currency) AS currency, SUM(CASE WHEN t.type = 'Inflow' THEN t.amount ELSE 0 END) AS inflows, SUM(CASE WHEN t.type = 'Outflow' THEN t.amount ELSE 0 END) AS outflows, SUM(CASE WHEN t.type = 'Transfer' AND t.amount < 0 THEN -t.amount ELSE 0 END) AS transfers_out, SUM(CASE WHEN t.type = 'Transfer' AND t.amount > 0 THEN t.amount ELSE 0 END) AS transfers_in FROM transactions t WHERE t.user_id = v_uid AND t.date = p_date GROUP BY t.account, upper(t.currency)), actual_bal AS (SELECT t.account, upper(t.currency) AS currency, SUM(CASE WHEN t.type = 'Inflow' THEN t.amount WHEN t.type = 'Outflow' THEN -t.amount ELSE 0 END) AS balance FROM transactions t WHERE t.user_id = v_uid AND t.date <= p_date AND t.type IN ('Inflow', 'Outflow') GROUP BY t.account, upper(t.currency)), api_override AS (SELECT ab.account, ab.currency, ab.api_balance AS balance FROM api_balances ab WHERE ab.user_id = v_uid AND ab.fetched_at::date = p_date), stripe_pending AS (SELECT sc.account_name AS account, upper(sc.currency) AS currency, sc.balance_pending AS pending FROM stripe_connections sc WHERE sc.user_id = v_uid AND sc.balance_fetched_at::date = p_date), gaps AS (SELECT ac.account, ac.currency, COALESCE(yb.balance, 0) AS yesterday_balance, COALESCE(tf.inflows, 0) AS today_inflows, COALESCE(tf.outflows, 0) AS today_outflows, COALESCE(tf.transfers_out, 0) AS transfers_out, COALESCE(tf.transfers_in, 0) AS transfers_in, COALESCE(ao.balance, ab.balance, 0) AS actual_balance, sp.pending AS stripe_pending, (COALESCE(yb.balance, 0) + COALESCE(tf.inflows, 0) - COALESCE(tf.outflows, 0) - COALESCE(tf.transfers_out, 0) + COALESCE(tf.transfers_in, 0)) AS expected_balance, COALESCE(f.rate, 1.0) AS fx_rate, (ao.balance IS NOT NULL) AS has_api_balance, (ac.currency <> 'EUR') AS is_non_eur, (p_date = (date_trunc('month', p_date) + interval '1 month - 1 day')::date) AS is_eom, (lower(ac.account) NOT LIKE '%stripe%' AND lower(ac.account) NOT LIKE '%paypal%' AND lower(ac.account) NOT LIKE '%payoneer%') AS is_banking FROM acct_currencies ac LEFT JOIN yesterday_bal yb ON yb.account = ac.account AND yb.currency = ac.currency LEFT JOIN today_flows tf ON tf.account = ac.account AND tf.currency = ac.currency LEFT JOIN actual_bal ab ON ab.account = ac.account AND ab.currency = ac.currency LEFT JOIN api_override ao ON ao.account = ac.account AND ao.currency = ac.currency LEFT JOIN stripe_pending sp ON sp.account = ac.account AND sp.currency = ac.currency LEFT JOIN fx_rates f ON f.curr = ac.currency) SELECT g.account, g.currency, g.expected_balance, g.actual_balance, (g.actual_balance - g.expected_balance) AS gap, g.yesterday_balance, g.fx_rate, g.stripe_pending, g.has_api_balance, g.is_non_eur, g.is_eom, g.is_banking FROM gaps g LOOP v_checked := v_checked + 1; DECLARE v_gap_abs numeric := ABS(rec.gap); v_gap_eur numeric := v_gap_abs * rec.fx_rate; v_yest_eur numeric := ABS(rec.yesterday_balance) * rec.fx_rate; v_severity text; v_status text := 'open'; v_auto_reason text; v_gap_pct numeric; BEGIN IF v_gap_abs < 0.01 THEN CONTINUE; END IF; v_gap_pct := CASE WHEN rec.yesterday_balance <> 0 THEN ROUND((v_gap_abs / ABS(rec.yesterday_balance)) * 100, 2) ELSE NULL END; IF v_gap_eur > GREATEST(5000, v_yest_eur * 0.05) THEN v_severity := 'critical'; ELSIF v_gap_eur > GREATEST(1000, v_yest_eur * 0.02) THEN v_severity := 'alert'; ELSIF v_gap_eur > GREATEST(200, v_yest_eur * 0.005) THEN v_severity := 'warning'; ELSE CONTINUE; END IF; IF rec.has_api_balance AND lower(rec.account) LIKE '%stripe%' THEN v_auto_reason := 'stripe_payout_lag'; v_status := 'expected'; ELSIF rec.is_non_eur AND v_gap_pct IS NOT NULL AND v_gap_pct < 2.0 THEN v_auto_reason := 'fx_rate_movement'; v_status := 'expected'; ELSIF rec.stripe_pending IS NOT NULL AND ABS(rec.gap - rec.stripe_pending) < 0.01 THEN v_auto_reason := 'stripe_pending_clearing'; v_status := 'expected'; ELSIF rec.is_eom AND v_gap_eur < 50 THEN v_auto_reason := 'eom_fee_batch'; v_status := 'expected'; ELSIF rec.is_banking AND v_gap_eur < 100 THEN v_auto_reason := 'bank_entry_timing'; v_status := 'expected'; END IF; v_found := v_found + 1; IF v_status = 'expected' THEN v_auto := v_auto + 1; END IF; INSERT INTO public.account_anomalies (account, detected_date, expected_balance, actual_balance, gap_amount, gap_percent, severity, status, auto_resolve_reason, user_id) VALUES (rec.account, p_date, rec.expected_balance, rec.actual_balance, rec.gap, v_gap_pct, v_severity, v_status, v_auto_reason, v_uid) ON CONFLICT (account, detected_date, user_id) DO UPDATE SET expected_balance = EXCLUDED.expected_balance, actual_balance = EXCLUDED.actual_balance, gap_amount = EXCLUDED.gap_amount, gap_percent = EXCLUDED.gap_percent, severity = EXCLUDED.severity, status = CASE WHEN account_anomalies.status IN ('dismissed', 'resolved') THEN account_anomalies.status ELSE EXCLUDED.status END, auto_resolve_reason = EXCLUDED.auto_resolve_reason; END; END LOOP; RETURN jsonb_build_object('checked', v_checked, 'anomalies_found', v_found, 'auto_resolved', v_auto); END; $$;